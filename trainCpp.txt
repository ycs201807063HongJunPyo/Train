// CTrain.cpp: 구현 파일
//

#include "pch.h"
#include "TrainMFC.h"
#include "afxdialogex.h"
#include "CTrain.h"

#define TRAIN_TIMER 10
#define WAIT_TIMER 11
// CTrain 대화 상자

IMPLEMENT_DYNAMIC(CTrain, CDialog)

//열차 구역
int railTopLeft[RAIL_NUM] = { 10,110,210,310,410,410,410,310,210,110,10,10,10 };
int railTopRight[RAIL_NUM] = { 110,210,310,410,510,510,510,410,310,210,110,110,110 };
int railBottomLeft[RAIL_NUM] = { 10,10,10,10,10,60,110,110,110,110,110,60,10 };
int railBottomRight[RAIL_NUM] = { 60,60,60,60,60,110,160,160,160,160,160,110,60 };
//겹치는 구역
BOOL rectResult;
CRect testRect;
int testT = 0;
CRect MainRectTest;
CRect tmpRect;
BOOL invRect;

CTrain::CTrain(CWnd* pParent /*=nullptr*/)
	: CDialog(IDD_MAINTRAIN, pParent)
{
	startFlag = TRUE;
	trainFlag = FALSE;
	trainSpeed = 0;
	trainCount = 0;
	trainX = 0;
	trainY = 0;
}

CTrain::~CTrain()
{
}

void CTrain::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_STATIC1, testText1);
	DDX_Control(pDX, IDC_STATIC2, testText2);
}


BEGIN_MESSAGE_MAP(CTrain, CDialog)
	ON_BN_CLICKED(IDSTART, &CTrain::OnBnClickedStart)
	ON_BN_CLICKED(IDSTOP, &CTrain::OnBnClickedStop)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_ERASEBKGND()
	//ON_WM_CTLCOLOR()
END_MESSAGE_MAP()


// CTrain 메시지 처리기
UINT ThreadMoveTrain(LPVOID param);


void CTrain::OnBnClickedStart()
{
	trainFlag = TRUE;

	arg1.hwnd = this->m_hWnd;
	arg1.type = 1;
	m_thread_move = AfxBeginThread(ThreadMoveTrain, &arg1, THREAD_PRIORITY_NORMAL, 0, 0);
	m_thread_move->ResumeThread();

	//SetTimer(TRAIN_TIMER, 50, NULL);
}


void CTrain::OnBnClickedStop()
{
	//가장 최근 스레드만 정지함
	m_thread_move->SuspendThread();
	/*
	KillTimer(TRAIN_TIMER);
	KillTimer(WAIT_TIMER);
	trainFlag = FALSE;
	*/
}

void CTrain::TimerFunction(int flag) {
	//열차 대기
	if (flag == 0) {
		KillTimer(TRAIN_TIMER);
		trainFlag = FALSE;
		SetTimer(WAIT_TIMER, 500, NULL);
	}
	//열차 출발
	else if (flag == 1) {
		KillTimer(WAIT_TIMER);
		trainFlag = TRUE;
		SetTimer(TRAIN_TIMER, 50, NULL);
	}

}

void CTrain::TrainMove(int left, int top, int right, int bottom) {
	//가상열차 위치 지정
	trainSize.left = left;
	trainSize.right = right;
	trainSize.top = top;
	trainSize.bottom = bottom;
}


void CTrain::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CDC MemDC;

	// 화면 DC와 호환되는 메모리 DC를 생성
	MemDC.CreateCompatibleDC(&dc);
	// 비트맵 리소스 로딩
	CBitmap bmp;
	CBitmap* pOldBmp = NULL;

	//맵 만들기
	MemDC.SelectObject(pOldBmp);
	//역 테두리 설정
	CPen myPen(PS_SOLID, 1, RGB(0, 0, 0));
	CPen* oldPen = dc.SelectObject(&myPen);
	int arraySize = (sizeof(railBottomLeft) / sizeof(*railBottomLeft));
	for (int i = 0; i < arraySize; i++) {
		//역 만들기
		dc.Rectangle(railTopLeft[i], railBottomLeft[i], railTopRight[i], railBottomRight[i]);
	}
	dc.SelectObject(oldPen);

	
	//출발 초록색 표시
	CBrush brush;
	CBrush* oldBrush = dc.SelectObject(&brush);
	brush.CreateSolidBrush(RGB(0, 255, 0));       // 초록
	oldBrush = dc.SelectObject(&brush);
//	dc.Rectangle(railTopLeft[testT], railBottomLeft[testT], railTopRight[testT], railBottomRight[testT]);

	//dc.Rectangle(testRect.left, testRect.top, testRect.right, testRect.bottom);
	dc.SelectObject(oldBrush);    // 시스템 브러시 객체를 돌려줌
	
	MemDC.SelectObject(pOldBmp);


}


void CTrain::OnTimer(UINT_PTR nIDEvent)
{
	CString test;
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	switch (nIDEvent)
	{
	case TRAIN_TIMER:
		//열차 속도 조절
		if (trainCount <= 6) {
			trainSpeed += 10;
		}
		else {
			trainSpeed -= 10;
		}

		//역에 도착하면 멈추기
		if (trainCount <= 4 && (60 + trainSpeed) == railTopRight[trainCount]) {
			testText1.SetWindowTextW(_T("1"));
			TimerFunction(0);
		}
		else if (trainCount >= 5 && trainCount <= 6 && (30 + trainSpeed) == railBottomRight[trainCount] - 10) {
			testText1.SetWindowTextW(_T("2"));
			TimerFunction(0);
		}

		else if (trainCount >= 5 && trainCount <= 10 && (60 + trainSpeed) == railTopRight[trainCount]) {
			testText1.SetWindowTextW(_T("3"));
			TimerFunction(0);
		}
		else if (trainCount >= 11 && trainCount <= 12 && (30 + trainSpeed) == railBottomRight[trainCount] - 10) {
			testText1.SetWindowTextW(_T("4"));
			TimerFunction(0);
		}

		break;
	case WAIT_TIMER:
		//시간 지나면 다시 움직이기
		trainCount++;
		testText1.SetWindowTextW(_T("동작함"));
		if (trainCount == 5) {
			trainSpeed = 20;
		}
		else if (trainCount == 7) {
			trainSpeed = trainX - 30;
		}
		else if (trainCount == 11) {
			trainSpeed = trainY - 30;
		}
		else if (trainCount == 13) {

			trainCount = 1;
			trainSpeed = 50;
			trainX = 0;
			trainY = 0;
		}
		TimerFunction(1);

		break;
	}
	CDialog::OnTimer(nIDEvent);
}


BOOL CTrain::OnEraseBkgnd(CDC* pDC)
{
	// TODO: 여기에 메시지 처리기 코드를 추가 및/또는 기본값을 호출합니다.
	CRect rect;
	GetClientRect(rect);
	pDC->FillSolidRect(rect, RGB(0, 0, 0));
	return CDialog::OnEraseBkgnd(pDC);
}

UINT DrawObject(LPVOID param)
{
	CTrain* pMain = (CTrain*)param;
	HwndArg* pArg = (HwndArg*)param;
	CDC dc;
	HDC hdc = ::GetDC(pArg->hwnd);
	CRect rect;
	int trainSpeed = 0;
	int trainLength = 60;
	int trainX;
	int trainY;
	CString tmp;

	rect = CRect(trainSpeed, 20, 30 + trainSpeed, 50);
	dc.Attach(hdc);

	int i = 0;
	while (1) {
		Sleep(100);
		if (i <= 6) {
			trainSpeed += 10;
		}
		else {
			trainSpeed -= 10;
		}
		rectResult = testRect.IntersectRect(&rect, &CRect(railTopLeft[i], railBottomLeft[i], railTopRight[i], railBottomRight[i]));
		//열차 이동
		if (i <= 4) {
			//오른
			rect = CRect(trainSpeed, 20, trainSpeed + 30, 50);
			InvalidateRect(pArg->hwnd, CRect(trainSpeed, 20, trainSpeed + 30, 50), TRUE);
			trainX = trainSpeed + 30;
		}
		else if (i <= 6) {
			//아래
			rect = CRect(trainX - 30, trainSpeed, trainX, 30 + trainSpeed);
			InvalidateRect(pArg->hwnd, CRect(trainX - 30, trainSpeed, trainX, 30 + trainSpeed), TRUE);
			trainY = 30 + trainSpeed;
		}
		else if (i <= 10) {
			//왼
			rect = CRect(trainSpeed, trainY - 30, trainSpeed + 30, trainY);
			InvalidateRect(pArg->hwnd, CRect(trainSpeed, trainY - 30, trainSpeed + 30, trainY), TRUE);
			trainX = trainSpeed + 30;

		}
		else if (i <= 12) {
			//위
			rect = CRect(trainX - 30, trainSpeed, trainX, 30 + trainSpeed);
			InvalidateRect(pArg->hwnd, CRect(trainX - 30, trainSpeed, trainX, 30 + trainSpeed), TRUE);
		}

		CBrush brush;
		CBrush* oldBrush = dc.SelectObject(&brush);

		if (IntersectRect(tmpRect, MainRectTest, CRect(railTopLeft[i], railBottomLeft[i], railTopRight[i], railBottomRight[i])) && invRect)
		{
			brush.CreateSolidBrush(RGB(0, 255, 0));       // 초록
			oldBrush = dc.SelectObject(&brush);
			dc.Rectangle(railTopLeft[i], railBottomLeft[i], railTopRight[i], railBottomRight[i]);
			OutputDebugString(_T("test\n"));
			InvalidateRect(pArg->hwnd, CRect(railTopLeft[i - 1], railBottomLeft[i - 1], railTopRight[i - 1], railBottomRight[i - 1]), TRUE);
			//invRect = FALSE;
		}

		/*
		//InvalidateRect(pArg->hwnd, NULL, TRUE);
		UpdateWindow(pArg->hwnd);
		CBrush brush;
		CBrush* oldBrush = dc.SelectObject(&brush);
		brush.CreateSolidBrush(RGB(0, 255, 0));       // 초록
		oldBrush = dc.SelectObject(&brush);
		dc.Rectangle(rect);
		dc.SelectObject(oldBrush);    // 시스템 브러시 객체를 돌려줌
		MainRectTest = rect;
		*/
		dc.SelectObject(oldBrush);
		dc.Rectangle(rect);
		MainRectTest = rect;
		//정차, 방향 조정
		if (i <= 4 && (60 + trainSpeed) == railTopRight[i]) {
			testT = i;

			Sleep(1000);
			i++;
			if (i == 5) {
				trainSpeed = 20;
			}
		}
		else if ((i >= 5 && i <= 6 && (30 + trainSpeed) == railBottomRight[i] - 10)) {
			testT = i;
			Sleep(1000);
			i++;
			if (i == 7) {
				trainSpeed = trainX - 30;
			}
		}
		else if (i >= 5 && i <= 10 && (60 + trainSpeed) == railTopRight[i]) {
			testT = i;
			Sleep(1000);
			i++;
			if (i == 11) {
				trainSpeed = trainY - 30;
			}
		}
		else if ((i >= 11 && i <= 12 && (30 + trainSpeed) == railBottomRight[i] - 10)) {
			testT = i;
			Sleep(1000);
			i++;
			if (i == 13) {
				i = 1;
				trainSpeed = 50;
				trainX = 0;
				trainY = 0;
			}
		}

		if (IntersectRect(tmpRect, MainRectTest, CRect(railTopLeft[i - 1], railBottomLeft[i - 1], railTopRight[i - 1], railBottomRight[i - 1])))
		{
			brush.CreateSolidBrush(RGB(0, 255, 0));       // 초록
			oldBrush = dc.SelectObject(&brush);
			dc.Rectangle(railTopLeft[i], railBottomLeft[i], railTopRight[i], railBottomRight[i]);
			OutputDebugString(_T("test\n"));
			InvalidateRect(pArg->hwnd, CRect(railTopLeft[i - 1], railBottomLeft[i - 1], railTopRight[i - 1], railBottomRight[i - 1]), TRUE);
			//invRect = TRUE;
		}
	}

	return 1;
}

UINT ThreadMoveTrain(LPVOID param)
{
	CTrain* pMain = (CTrain*)param;
	ThreadArg* pArg = (ThreadArg*)param;
	CDC dc;
	HDC hdc = ::GetDC(pArg->hwnd);
	CBrush brush = RGB(255, 255, 255);
	dc.Attach(hdc);

	switch (pArg->type)
	{
	case 1:
		dc.SelectObject(&brush);
		while (0 != DrawObject(pMain))
		{
			DrawObject(pMain);
		}
		break;
	case 2:

		break;

	default:
		break;
	}

	dc.Detach();
	::ReleaseDC(pArg->hwnd, hdc);

	return 0;
}


/*
CString test;
			test.Format(L"%d", bmpInfo.bmHeight + trainSpeed);
			testText1.SetWindowTextW(test);
			test.Format(L"%d", trainCount);
			testText2.SetWindowTextW(test);
*/



/*

HBRUSH CTrain::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{

	HBRUSH hbr;


	if (nCtlColor == CTLCOLOR_STATIC)	//STATIC 컨트롤만 배경색 변경
		pDC->SetBkColor(RGB(0, 0, 0));	//배경색 변경

	hbr = (HBRUSH)GetStockObject(NULL_BRUSH);
	return hbr;

}
*/